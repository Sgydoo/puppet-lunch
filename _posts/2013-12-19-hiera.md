---
layout: page
title:  "Chapter 3 - Using Hiera"
date:   2013-12-19 12:13:48
categories: puppet
---

Hiera allows hierarchical configuration in Puppet, which is difficult
to achieve with native Puppet code. Another major advantage is the
separation of configuration data from the code, which makes everything
generally easier. This is probably why Hiera comes bundled with Puppet
Enterprise. To get a feel for what it can do, see the [Puppet Labs
Overview of Hiera][hiera-overview].

## Basic Configuration

For testing purposes, we're going to create a very simple Hiera-
based Puppet Master configuration. At this point, we only have the
three Puppet hosts to play with so we'll verify the configuration on
these nodes first. To keep things simple, we'll follow the Hiera
configuration example from the Overview, so this will be the order
of events:

*  Make a hiera.yaml config file.
*  Arrange a hierarchy that fits your site and data.
*  Write data sources.
*  Use your Hiera data in Puppet.

To get to grips with Hiera, it makes sense to follow the [Puppet Labs
complete example][hiera-complete-example], in which the ntp service is
configured. We need to install the ntp puppet module...

{% highlight text %}
# puppet module install puppetlabs/ntp
Notice: Preparing to install into /etc/puppetlabs/puppet/modules ...
Notice: Downloading from https://forge.puppetlabs.com ...
Notice: Installing -- do not interrupt ...
/etc/puppetlabs/puppet/modules
└── puppetlabs-ntp (v2.0.1)
{% endhighlight %}

### hiera.yaml and The Hierarchy

Hiera's hierarchy configuration is in
/etc/puppetlabs/puppet/hiera.yaml. If we edit this file, then Puppet
needs to be restarted before it will pick up the changes (service
pe-puppet restart). The default config looks like this:

{% highlight yaml %}
---
:backends:
  - yaml
:hierarchy:
  - defaults
  - "%{clientcert}"
  - "%{environment}"
  - global
:yaml:
# datadir is empty here, so hiera uses its defaults:
# - /var/lib/hiera on *nix
# - %CommonAppData%\PuppetLabs\hiera\var on Windows
# When specifying a datadir, make sure the directory exists.
  :datadir:
{% endhighlight %}

Hiera configuration is in /var/lib/hiera by default. To keep
everything in one place, we'll change this to
/etc/puppetlabs/puppet/hiera. We'll also change the hierarchy a bit,
so the new config file looks like this:

{% highlight yaml %}
---
:backends:
  - yaml
:hierarchy:
    - node/%{::fqdn}
    - "%{::environment}/%{::role}"
    - role/%{::role}
    - "%{::environment}"
    - global
:yaml:
  :datadir: /etc/puppetlabs/puppet/hiera
{% endhighlight %}

Note the double-colon forces these variables to be top-scope. We do
this to remove any ambiguity which may arise if a module were to
define a variable of the same name. Top scope name space is the empty
string, which is why nothing preceeds the double-colon.

This Hiera configuration provides a huge amount of flexibility. It allows:

* A global configuration standard for all nodes, which would correspond with any standard build policy.
* The ability to override the global configuration for a particular environment and a particular node.
* The ability to define a role for each node.
* The ability to vary a role definition on a per-environment basis.

For example, if we create a new node called 'webserver1' with the role
'web' and environment 'uat', Hiera will search for Puppet module
parameters in the following files:

{% highlight text %}
1. /etc/puppetlabs/puppet/hiera/node/webserver1.yaml    
2. /etc/puppetlabs/puppet/hiera/uat/web.yaml            
3. /etc/puppetlabs/puppet/hiera/web.yaml                
4. /etc/puppetlabs/puppet/hiera/uat.yaml                
5. /etc/puppetlabs/puppet/hiera/global.yaml             
{% endhighlight %}

So that's:

1. Specific config for this particular server
2. Config for all UAT web servers
3. Config for all web servers
4. Config for all nodes in UAT
5. Common config for all nodes

One important thing to note is that Puppet will search for module
parameters automatically. It doesn't have to be explicitly configured
to search Hiera data unless the module uses 'defined types'. See the
Using Hiera with Defined Types section later in this page.

This configuration also allows us to implement the "roles/profiles"
approach, which is becoming popular with Puppet administrators. An
end-to-end example is provided in [this 'ask puppetlabs' post][end-to-end].

You can also find an account of how we implemented Roles and Profiles
in <a href="{{ site.baseurl }}/puppet/roles-and-profiles.html">Appendix
C - Node Classification: Roles & Profiles</a>, but it's better
to get to grips with Hiera and try a few things out yourself before
diving into that.

#### Example: Data Sources and the ntp Service

Data sources are written in YAML, which is a really simple
human-readable data format. For a quick glance at how data structures
are represented in YAML, [read this][yaml-for-ruby].

For example, when configuring the ntp service, we can define any
global options in global.yaml:

{% highlight text %}
ntp::package_ensure: latest
ntp::service_enable: true
ntp::service_ensure: running
ntp::servers:
  - ntp0.puppetlunch.com iburst
  - ntp1.puppetlunch.com iburst
  - ntp2.puppetlunch.com iburst
  - ntp3.puppetlunch.com iburst
ntp::driftfile: /var/lib/ntp/drift
{% endhighlight %}

Any of these options may be overriden further up the hierarchy. So for
example, if we have an environment called "uat" in which we didn't
want to run the ntp service, we could put this in uat.yaml:

{% highlight yaml %}
ntp::service_ensure: stopped
{% endhighlight %}

To test this, we can run the hiera command line tool, which allows you
to test your Hiera configuration without repeated puppet agent runs:

{% highlight text %}
# hiera ntp::service_ensure ::environment=uat
stopped
# hiera ntp::service_ensure ::environment=dev
running
{% endhighlight %}

However, if we wanted to run the ntp service on a particular node in
uat called "uat-web1.puppetlunch.com" we can do this no problem in node/uat-
web1.puppetlunch.com.yaml:

{% highlight yaml %}
ntp::service_ensure: running
{% endhighlight %}

And test:

{% highlight text %}
# hiera ntp::service_ensure ::environment=uat
stopped
# hiera ntp::service_ensure ::environment=uat ::fqdn=uat-web1.puppetlunch.com
running
{% endhighlight %}

### Using Hiera Data in Puppet

As mentioned previously, Puppet automatically searches Hiera data for
module parameters. So when we enable the ntp class in the default node
configuration in site.pp, everything Just Works:

File: /etc/puppetlabs/puppet/manifests/site.pp
 
{% highlight text %}
node default {
  # This is where you can declare classes for all nodes.
  # Example:
  #   class { 'my_class': }

  # First test: ntp. This includes the puppetlabs ntp module, which should
  # pick up its parameters from Hiera automatically.
  include ntp
}
{% endhighlight %}

Alternatively, we can use the [hiera_include][hiera-include] function
to enable various classes from within the hiera data sources:

File: /etc/puppetlabs/puppet/manifests/site.pp
 
{% highlight text %}
hiera_include('classes')
{% endhighlight %}

Then we define the 'classes' array in global.yaml:

{% highlight text %}
#
# Specify which classes to enable
#
classes:
  - ntp
  - motd
{% endhighlight %}

This provides the magical ability to enable and disable classes from
the global configuration file, rather than editing the Puppet
site.pp manifest.

Another option would be to leave the classes array undefined in
global.yaml and enable the appropriate classes per environment, or
even per node.

### Using Hiera with Defined Types

Sometimes the options required by a particular module are a bit more
complex; usually because the module has defined a particular resource
type. In these cases, Puppet's automatic parameter lookup function
will fail, but we can help it to find what it's looking for using the
built-in functions [hiera][fn-hiera] and [create_resources][fn-create_resources].

Here's an example of the data structure required by the
puppetlabs/apache module, which defines its own resource type
'apache::vhost':

{% highlight text %}
apache::vhost { 'foo.example.com':
      port          => '80',
      docroot       => '/var/www/foo.example.com',
      docroot_owner => 'foo',
      docroot_group => 'foo',
      options       => ['Indexes','FollowSymLinks','MultiViews'],
      proxy_pass    => [ { 'path' => '/a', 'url' => 'http://backend-a/' } ],
}
 
apache::vhost { 'bar.example.com':
    port     => '80,
    docroot: => '/var/www/bar.example.com',
}
{% endhighlight %}

So it's a "hash of hashes" data structure, which can be represented in
YAML like this:

{% highlight yaml %}
apache::vhosts:
  foo.example.com:
    port: 80
    docroot: /var/www/foo.example.com
    docroot_owner: foo
    docroot_group: foo
    options:
      - Indexes
      - FollowSymLinks
      - MultiViews
    proxy_pass:
      -
        path: '/a'
        url: 'http://localhost:8080/a'
  bar.example.com:
    port: 80
    docroot: /var/www/bar.example.com
{% endhighlight %}

To use the data in our Puppet code, we need to pull the Hiera data
into a hash variable, then define the resource that this hash
represents using the 'create_resources' function:

{% highlight text %}
$myvhosts = hiera('apache::vhosts', {})
create_resources('apache::vhost', $myvhosts)
{% endhighlight %}

The first line assigns the YAML data structure to a hash variable, and
the second tells Puppet to use this hash to declare an 'apache::vhost'
resource type for each key in the hash.

#### create_resources: The General Solution

1\. Take a complex data structure like this:

{% highlight text %}
defined_type { 'name':
  key1 => 'value1',
  key2 => 'value2',
  key3 => ['element1','element2','element3']
  key4 => [ { 'subkey1' => 'subvalue1', 'subkey2' => 'subvalue2' } ],
}
{% endhighlight %}

2\. Represent it in YAML:

{% highlight yaml %}
data_identifier:
  name:
    key1: value1
    key2: value2
    key3:
      - element1
      - element2
      - element3
    key4:
      -
        subkey1: subvalue1
        subkey2: subvalue2
{% endhighlight %}

3\. Pull the Hiera data into a Puppet variable (the 'hiera' function
will only pull the data relevant to a particular node, as dictated
by your hierarchy):

{% highlight text %}
$my_hash = hiera('data_identifier', {})
{% endhighlight %}

4\. Pass the data to the resource type:

{% highlight text %}
create_resources('defined_type', $my_hash)
{% endhighlight %}

Note that for simplicity, 'data_identifier' is usually the same string
as 'defined_type', but it's important to realise that it can be
anything you like. This is the key to understanding how it works -
you're *either* using Puppet's auto-lookup feature, in which case the
data identifier has to match the resource name, *or* you're using
create_resources, in which case there's no auto-lookup and the data
identifier can be anything you want.

## Further Reading

A comprehensive list and description of all Puppet's built-in functions:

* [Puppet Function Reference][pe-functionref]

## Next...

* <a href="{{ site.baseurl }}/puppet/autoprovisioning.html">Chapter 4 - Auto-provisioning With Cloud Provisioner</a>
* <a href="{{ site.baseurl }}/contents">Table of Contents</a>

[hiera-overview]: http://docs.puppetlabs.com/hiera/1/index.html
[hiera-complete-example]: http://docs.puppetlabs.com/hiera/1/complete_example.html
[pe-functionref]: http://docs.puppetlabs.com/references/3.stable/function.html
[fn-create_resources]: http://docs.puppetlabs.com/references/3.stable/function.html#createresources
[fn-hiera]: http://docs.puppetlabs.com/references/3.stable/function.html#hiera
[end-to-end]: https://ask.puppetlabs.com/question/1655/an-end-to-end-roleprofile-example-using-hiera/
[yaml-for-ruby]: http://www.yaml.org/YAML_for_ruby.html
[hiera-include]: http://docs.puppetlabs.com/references/latest/function.html#hierainclude
